URGENT : faut faire les classes définitives Formula, Clause, Variable en regardant ce que dpll a besoin
	ensuite je pourrai adapter ton tseitin.
	=> Je commence à faire des trucs propres.

Je pense que le mieux pour concevoir une API c'est d'abord de programmer un exemple.

Optionnel : ce serait cool que tes variables puissent déjà contenir l'information comme quoi on prend l'opposé (genre -2, voire même ~~-2), ça facilitera la tâche (mais c'est optionnel, te concentre pas là-dessus, on aura le temps d'y revenir)
	=> faudra voir ça effectivement

IL faut traiter l'entrée pour que 1 \/ 1000 devienne 0 \/ 1 une fois stocké
et garder l'association inverse 0 -> 1; 1 -> 1000.

Faut utiliser des enum class avec des noms appropriés

Si tu as le temps jettes un coup d'oeil à Clean Code dans /doc/

J'ai commencé l'algo DPLL, voir dpll.hpp, dpll.cpp

Il faut renommer les .h en .hpp (si c'est bien un fichier C++)

Il faut trouver des noms pour les Fomula (entrée) et (données utilisée DPLL)

Il faut que tu ranges ce bordel de fichiers et de dossiers.
	L'arborescence sera src/parser src/tseitin src/solver
	avec un bon gros Makefile (en racine) ???? permettant de compiler (seulement le parser ou le solveur ou bien tout, faire des tests, ...)

Il faut créer un fichier conventions de codage ?
	#HirshkoffVaAdorer

Faut pas oublier de faire des tests.

Faut trouver le type d'include à faire : "" ou <>, doit on include subdir/header.h ou juste header.h et préciser dans le Makefile (si c'est possible)
	=> Pour moi les includes c'est <> pour la lib standard, et "" pour les header personnel. C'est comme ça que j'ai appris, je ne sais pas quelle liberté on a. 

Heuristique : on pourrait compter le nombre de littéraux 1 -1 1 donne 2 * 1, 1 * -1 puis trier les clauses selon cet ordre

Faut nettoyer le makefile

Un gros Makefile à la racine ou bien un makefile dans chaque répertoire ? ça se discutte
	=> Au pire, un makefile dans chaque répertoire ET un makefile à la racine qui permet de compiler via les autres makefile

Coder des générateurs d'instance SAT
	- aléatoire
	- combinatoire: issue d'une réduction d'un problème (exemple: coloration d'un graphe choisi au hasard pusi codé en CNF)

Les conventions utilisées par ls

   Exit status:
       0      if OK,

       1      if minor problems (e.g., cannot access subdirectory),

       2      if serious trouble (e.g., cannot access command-line argument).

Commande pour stocker le projet dans le dossier courant sans créer de sous dossier :
	git clone git@github.com:EnguerrandPrebet/Projet-2.git .

// NOUVELLLES REMARQUES et CONVENTIONS !!!!!!

Pour que QtCreator puisse intelligemment trouver en-tête / source ils faut que les fichiers soient ouverts dans l'éditeur.
Refactoriser marche bien : il met en rouge la variable [var], on tape simplement le nouveau nom puis on clique à côté et c'est bon (il me semble).
Pour que QtCreator indente toujours avec des tabs il faut le préciser dans options de "l'éditeur" et dans "c++" indenter avec tabs.

Il me semble qu'il serait vraiment plus simple de mettre les options de debug dans un objet global (définit dans options.hpp ?) que main set et qui sera accessible facilement.
Plutôt que de passer des const Option& aux classes qui le passent à leurs enfants qui le passent à leurs petits enfants, ... tel un lourd boulet :-D

Il faut bien être const-correct, quand tu fournis un accesseur &, donne également un accesseur référence constant.
De même si une méthode ne modifie pas un argument il faut bien utiliser const &.

Il faut respecter la convention names_with_underscores.

Quand on fait #include <header_wtf_qui_sort_de_n_importe_ou>, on précise // pour f()

Dans les header et les prédéclarations de fonctions il faut mettre les noms des paramètres seulement lorsque ce n'est pas déjà clair sans
	exemple : abs(int) convient, mais pour print_debug_msg(Debug_struct, string owner, string msg), le rôle des deux derniers arguments n'est pas clair d'après les types.

// DANS UN FUTUR LOINTAIN
A priori pas de utils.hpp, les petites fonctions restent dans les .cpp

Il faudrait ajouter une option -io_only qui se contente de lire l'entrée et de construire la formule pour pouvoir faire des tests de performance

Dans treat_cnf tu gères les clauses mal terminées mais dans ce cas tu ajoutes quand même les variables de ces clauses, il faudra choisir ce que l'on fait dans ce cas

Tu pourrais jeter un coup d'oeil à Clean Code, ça donne une méthodologie solide.

Trouver un outil qui check la minimalité des dépendances des headers

Utiliser un outil d'analyse de propreté du code pour trouver quelles fonctions il faut "couper"

Faire un profiling sérieux pour voir où sont les inefficacités.

Rendre plus propre le code de Formula_input,  créer la classe Renaming utile pour tseitin et pour treat_cnf
