Idées en vrac:
Pour que le code soit efficace malgré les if (heuristique == ...)
Il faut bien faire comprendre au compilateur que si l'heuristique choisie est F
alors elle restera F durant toute la fonction dpll. => variable static constante ?

On fait des piles (pour backtracker) pour chaque heuristique ?

API
	next_variable(heuristique (variable globale))
	set_variable(x_i, valeur)
	//litteral -> liste des clauses "vivantes" qui le contiennent

	
	NONE (dans tous les cas) - heuristique "avancer"
		connaître la liste (dynamique) des clauses de taille 0 / 1 => donc la taille des clauses
			Si on utilisait une file de priorité avec pour indices (taille de la clause) et pour valeurs (numéros de la clause) ?
		

	RAND
		On doit connaître l'ensemble des variables non affectées
		
	MOMS
		
	DLIS
	

Toutes les affectations x_i <- true / false
doivent être faites à travers une interface qui permet de mettre à jour
les structures de données "annexes"

Tant que (il reste des clauses à satisfaire)
	DEDUCTIONS
	Clause vide:
		BACKTRACKING
	Clauses unitaires: Pour tout clause de taille 1
		déduire la valeur de X
	Polarité unique:
	
	
	
	
	CHOIX
	x_i = next_variable();
	mettre à jour les structures de données
